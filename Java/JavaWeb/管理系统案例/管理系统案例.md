# 管理系统案例

## 一、准备工作

完成的功能

+ 部门管理
  + 部门的查询、新增、删除
+ 员工管理
  + 员工信息的条件、分页查询、新增员工、编辑、删除

### 1. 环境搭建

+ 准备数据库表（dept、emp）
+ 创建 springboot 工程，引入对应的起步依赖（web、mybatis、mysql 驱动、lombok）
+ 配置文件 application.properties 中引入 mybatis 的配置信息，准备对应的实体类
+ 准备对应的 Mapper、Service（接口、实现类）、Controller 基础结构

<img src="./assets/image-20250729233825189.png" alt="image-20250729233825189" style="zoom:50%;" />

### 2. 建表

```sql
-- 部门管理
create table dept(
    id int unsigned primary key auto_increment comment '主键ID',
    name varchar(10) not null unique comment '部门名称',
    create_time datetime not null comment '创建时间',
    update_time datetime not null comment '修改时间'
) comment '部门表';

insert into dept (id, name, create_time, update_time) values(1,'学工部',now(),now()),(2,'教研部',now(),now()),(3,'咨询部',now(),now()), (4,'就业部',now(),now()),(5,'人事部',now(),now());


-- 员工管理(带约束)
create table emp (
  id int unsigned primary key auto_increment comment 'ID',
  username varchar(20) not null unique comment '用户名',
  password varchar(32) default '123456' comment '密码',
  name varchar(10) not null comment '姓名',
  gender tinyint unsigned not null comment '性别, 说明: 1 男, 2 女',
  image varchar(300) comment '图像',
  job tinyint unsigned comment '职位, 说明: 1 班主任,2 讲师, 3 学工主管, 4 教研主管, 5 咨询师',
  entrydate date comment '入职时间',
  dept_id int unsigned comment '部门ID',
  create_time datetime not null comment '创建时间',
  update_time datetime not null comment '修改时间'
) comment '员工表';

INSERT INTO emp
	(id, username, password, name, gender, image, job, entrydate,dept_id, create_time, update_time) VALUES
	(1,'jinyong','123456','金庸',1,'1.jpg',4,'2000-01-01',2,now(),now()),
	(2,'zhangwuji','123456','张无忌',1,'2.jpg',2,'2015-01-01',2,now(),now()),
	(3,'yangxiao','123456','杨逍',1,'3.jpg',2,'2008-05-01',2,now(),now()),
	(4,'weiyixiao','123456','韦一笑',1,'4.jpg',2,'2007-01-01',2,now(),now()),
	(5,'changyuchun','123456','常遇春',1,'5.jpg',2,'2012-12-05',2,now(),now()),
	(6,'xiaozhao','123456','小昭',2,'6.jpg',3,'2013-09-05',1,now(),now()),
	(7,'jixiaofu','123456','纪晓芙',2,'7.jpg',1,'2005-08-01',1,now(),now()),
	(8,'zhouzhiruo','123456','周芷若',2,'8.jpg',1,'2014-11-09',1,now(),now()),
	(9,'dingminjun','123456','丁敏君',2,'9.jpg',1,'2011-03-11',1,now(),now()),
	(10,'zhaomin','123456','赵敏',2,'10.jpg',1,'2013-09-05',1,now(),now()),
	(11,'luzhangke','123456','鹿杖客',1,'11.jpg',5,'2007-02-01',3,now(),now()),
	(12,'hebiweng','123456','鹤笔翁',1,'12.jpg',5,'2008-08-18',3,now(),now()),
	(13,'fangdongbai','123456','方东白',1,'13.jpg',5,'2012-11-01',3,now(),now()),
	(14,'zhangsanfeng','123456','张三丰',1,'14.jpg',2,'2002-08-01',2,now(),now()),
	(15,'yulianzhou','123456','俞莲舟',1,'15.jpg',2,'2011-05-01',2,now(),now()),
	(16,'songyuanqiao','123456','宋远桥',1,'16.jpg',2,'2007-01-01',2,now(),now()),
	(17,'chenyouliang','123456','陈友谅',1,'17.jpg',NULL,'2015-03-21',NULL,now(),now());

```

### 3. 创建文件

<img src="./assets/image-20250730000043769.png" alt="image-20250730000043769" style="zoom:50%;" />

+ mapper 用 @Mapper
+ controller 用 @Controller
+ service 用 @Service

具体文件配置参照前面的笔记

### 4. 开发规范

案例基于当前最为主流的前后端分离模式进行开发

#### 4.1 Restful

+ REST（REpresentational State Transfer），表述性状态转换，它是一种软件架构风格

<img src="./assets/image-20250730000758586.png" alt="image-20250730000758586" style="zoom:50%;" />

<img src="./assets/image-20250730000850754.png" alt="image-20250730000850754" style="zoom:50%;" />

注意事项

+ REST 是风格，是约定方式，约定不是规定，可以打破
+ 描述模块的功能通常使用复数，也就是加 s 的格式来描述，标识此类资源，而非单个资源。如：users、emps、books ...

#### 4.2 统一响应结果

+ 前后端交互统一响应结果 Result

```java
package com.itheima.pojo;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class Result {
    private Integer code;//响应码，1 代表成功; 0 代表失败
    private String msg;  //响应信息 描述字符串
    private Object data; //返回的数据

    //增删改 成功响应
    public static Result success(){
        return new Result(1,"success",null);
    }
    //查询 成功响应
    public static Result success(Object data){
        return new Result(1,"success",data);
    }
    //失败响应
    public static Result error(String msg){
        return new Result(0,msg,null);
    }
}
```

### 5. 开发流程

<img src="./assets/image-20250730001231801.png" alt="image-20250730001231801" style="zoom:50%;" />



--------------------



## 二、部门管理

### 1. 查询部门

+ 查询全部数据（由于部门数据比较少，不考虑分页）

<img src="./assets/image-20250730002759853.png" alt="image-20250730002759853" style="zoom:50%;" />

流程：

前端发送请求到 Controller 的方法，方法中首先调用 Service 来获取数据，在 Service 中调用了 Mapper 接口中的方法来查询全部的部门信息，Mapper 接口就会往数据库当中发送 sql 语句

+ DeptController.java

```java
package com.itfeng.controller;

import com.itfeng.pojo.Dept;
import com.itfeng.pojo.Result;
import com.itfeng.service.DeptService;
import lombok.extern.slf4j.Slf4j;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

/**
 * 部门管理Controller
 */
//@Slf4j // 会自动定义日志记录对象
@RestController
public class DeptController {

    private static Logger log = LoggerFactory.getLogger(DeptController.class);

    @Autowired
    private DeptService deptService;

    //    @RequestMapping(value = "/depts", method = RequestMethod.GET) // 指定请求方式为GET
    @GetMapping("/depts")
    public Result list() {
        log.info("查询全部部门数据");

        // 调用Service查询部门数据
        List<Dept> deptList = deptService.list();

        return Result.success(deptList);
    }
}
```

+ DeptService.java

```java
package com.itfeng.service;

import com.itfeng.pojo.Dept;

import java.util.List;

public interface DeptService {
    /**
     * 查询全部部门数据
     *
     * @return
     */
    List<Dept> list();
}
```

+ DeptServiceImpl.java

```java
package com.itfeng.service.impl;

import com.itfeng.mapper.DeptMapper;
import com.itfeng.pojo.Dept;
import com.itfeng.service.DeptService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class DeptServiceImpl implements DeptService {

    @Autowired
    private DeptMapper deptMapper;

    @Override
    public List<Dept> list() {
        return deptMapper.list();
    }
}
```

+ DeptMapper.java

```java
package com.itfeng.mapper;

import com.itfeng.pojo.Dept;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Select;

import java.util.List;

/**
 * 部门管理
 */
@Mapper
public interface DeptMapper {
    /**
     * 查询全部部门
     *
     * @return
     */
    @Select("select * from dept")
    List<Dept> list();
}
```



----------------------------------



### 2. 前后端联调

+ 启动 nginx，访问测试：http://localhost:90/

<img src="./assets/image-20250802165957296.png" alt="image-20250802165957296" style="zoom:50%;" />

#### 小结

1. 开发流程

+ 明确需求、接口文档、思路分析、接口开发

2. 接口调试

+ postman 测试、前后端联调

3. 日志小技巧

+ @Slf4j



-----------------------------



### 3. 删除部门

<img src="./assets/image-20250802170730966.png" alt="image-20250802170730966" style="zoom:50%;" />

+ DeptController.java

```java
/**
 * 删除部门
 *
 * @return
 */
@DeleteMapping("/depts/{id}")
public Result delet(@PathVariable Integer id) {
    log.info("根据id删除部门：{}", id);
    // 调用service删除部门
    deptService.delete(id);
    return Result.success();
}
```

+ DeptService.java

```java
/**
 * 删除部门
 *
 * @param id
 */
void delete(Integer id);
```

+ DeptServiceImpl.java

```java
@Override
public void delete(Integer id) {
    deptMapper.deleteById(id);
}
```

+ DeptMapper

```java
/**
 * 删除部门
 * @param id
 */
@Delete("delete from dept where id = #{id}")
void deleteById(Integer id);
```



------------------------



### 4. 新增部门

<img src="./assets/image-20250802174050247.png" alt="image-20250802174050247" style="zoom:50%;" />

+ DeptController.java

```java
/**
 * 新增部门
 *
 * @return
 */
@PostMapping("/depts")
public Result add(@RequestBody Dept dept) {
    log.info("新增部门：{}", dept);
    // 调用Service新增部门
    deptService.add(dept);
    return Result.success();
}
```

+ DeptService.java

```java
/**
 * 新增部门
 * @param dept
 */
void add(Dept dept);
```

+ DeptServiceImpl.java

```java
@Override
public void add(Dept dept) {
    dept.setCreateTime(LocalDateTime.now());
    dept.setUpdateTime(LocalDateTime.now());

    deptMapper.insert(dept);
}
```

+ DeptMapper.java

```java
/**
 * 新增部门
 * @param dept
 */
@Insert("insert into dept(name, create_time, update_time) values (#{name}, #{createTime}, #{updateTime})")
void insert(Dept dept);
```



代码优化：

+ DeptController.java

```java
package com.itfeng.controller;

import com.itfeng.pojo.Dept;
import com.itfeng.pojo.Result;
import com.itfeng.service.DeptService;
import lombok.extern.slf4j.Slf4j;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import java.util.List;

/**
 * 部门管理Controller
 */
//@Slf4j // 会自动定义日志记录对象
@RequestMapping("/depts") // 指定公共路径
@RestController
public class DeptController {

    private static Logger log = LoggerFactory.getLogger(DeptController.class);

    @Autowired
    private DeptService deptService;

    /**
     * 查询部门数据
     *
     * @return
     */
    //    @RequestMapping(value = "/depts", method = RequestMethod.GET) // 指定请求方式为GET
    @GetMapping
    public Result list() {
        log.info("查询全部部门数据");

        // 调用Service查询部门数据
        List<Dept> deptList = deptService.list();

        return Result.success(deptList);
    }

    /**
     * 删除部门
     *
     * @return
     */
    @DeleteMapping("/{id}")
    public Result delet(@PathVariable Integer id) {
        log.info("根据id删除部门：{}", id);
        // 调用service删除部门
        deptService.delete(id);
        return Result.success();
    }

    /**
     * 新增部门
     *
     * @return
     */
    @PostMapping
    public Result add(@RequestBody Dept dept) {
        log.info("新增部门：{}", dept);
        // 调用Service新增部门
        deptService.add(dept);
        return Result.success();
    }
}
```



-------------------------



## 三、员工管理

### 1. 分页查询

+ 回顾

```sql
-- 分页查询语法
-- 参数1：起始索引 = （页码 - 1）*每页展示记录数
-- 参数2：查询返回记录数 = 每页展示记录数
select * from emp limit 0, 5;

-- 查询第一页数据，每页展示5条记录
select * from emp limit 0, 5;

-- 查询第三页数据，每页展示5条记录
select * from emp limit 10, 5;
```

<img src="./assets/image-20250802204452694.png" alt="image-20250802204452694" style="zoom:50%;" />

<img src="./assets/image-20250802204808580.png" alt="image-20250802204808580" style="zoom:50%;" />

`@RequestParam` 的属性 `defaultValue` 可以来设置参数的默认值

+ PageBean.java

```java
package com.itfeng.pojo;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

/**
 * 分页查询封装类
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class PageBean {

    private Long total; // 总记录数
    private List rows; // 数据列表
}
```

+ EmpController.java

```java
@Autowired
private EmpService empService;

@GetMapping("/emps")
public Result page(@RequestParam(defaultValue = "1") Integer page,
                   @RequestParam(defaultValue = "10") Integer pageSize) {
    log.info("分页查询，参数：{}，{}",page, pageSize);
    // 调用service分页查询
    PageBean pageBean = empService.page(page, pageSize);
    return Result.success(pageBean);
}
```

+ EmpService.java

```java
package com.itfeng.service;

import com.itfeng.pojo.PageBean;

public interface EmpService {
    /**
     * 分页查询
     * @param page
     * @param pageSize
     * @return
     */
    PageBean page(Integer page, Integer pageSize);
}
```

+ EmpServiceImpl.java

```java
package com.itfeng.service.impl;

import com.itfeng.mapper.EmpMapper;
import com.itfeng.pojo.Emp;
import com.itfeng.pojo.PageBean;
import com.itfeng.service.EmpService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class EmpServiceImpl implements EmpService {

    @Autowired
    private EmpMapper empMapper;

    @Override
    public PageBean page(Integer page, Integer pageSize) {
        // 1. 获取总记录数
        Long count = empMapper.count();

        // 2. 获取分页查询结果列表
        Integer start = (page - 1) * pageSize;
        List<Emp> empList = empMapper.page(start, pageSize);

        // 3. 封装PageBean对象
        PageBean pageBean = new PageBean(count, empList);
        return pageBean;
    }
}
```

+ EmpMapper.java

```java
package com.itfeng.mapper;

import com.itfeng.pojo.Emp;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Select;

import java.util.List;

/**
 * 员工管理
 */
@Mapper
public interface EmpMapper {

    /**
     * 查询总记录数
     *
     * @return
     */
    @Select("select count(*) from emp;")
    public Long count();

    /**
     * 分页查询，获取列表数据
     *
     * @param start
     * @param pageSize
     * @return
     */
    @Select("select * from emp limit #{start}, #{pageSize};")
    public List<Emp> page(Integer start, Integer pageSize);
}
```

#### 小结

1. 分页查询

+ 请求参数：页码、每页展示记录数
+ 响应结果：总记录数、结果列表（PageBean）

2. 注解

```java
@RequestParam(defaultValue="1") // 设置请求参数默认值
```

#### 分页插件 PageHelper

<img src="./assets/image-20250810163645263.png" alt="image-20250810163645263" style="zoom:50%;" />

依赖（针对 springboot3）：

```xml
<dependency>
    <groupId>com.github.pagehelper</groupId>
    <artifactId>pagehelper-spring-boot-starter</artifactId>
    <version>1.4.6</version>
</dependency>
```

+ **EmpController 不变**，因为 Controller 与前端交互，后端技术迭代不影响

+ EmpMapper.java

```java
/**
 * 员工信息的查询
 */
@Select("select * from emp")
public List<Emp> list();
```

+ EmpServiceImpl.java

```java
@Override
public PageBean page(Integer page, Integer pageSize) {

    // 1. 设置分页参数
    PageHelper.startPage(page, pageSize);

    // 2. 执行查询
    List<Emp> empList = empMapper.list();
    Page<Emp> p = (Page<Emp>) empList;

    // 3. 封装PageBean对象
    PageBean pageBean = new PageBean(p.getTotal(), p.getResult());
    return pageBean;
}
```



----------------------



### 2. 条件分页查询

<img src="./assets/image-20250810172414999.png" alt="image-20250810172414999" style="zoom:50%;" />

+ EmpController.java

```java
package com.itfeng.controller;

import com.itfeng.pojo.PageBean;
import com.itfeng.pojo.Result;
import com.itfeng.service.EmpService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import java.time.LocalDate;
import java.time.LocalDateTime;

/**
 * 员工管理Controller
 */
@RestController
public class EmpController {

    private static Logger log = LoggerFactory.getLogger(DeptController.class);

    @Autowired
    private EmpService empService;

    @GetMapping("/emps")
    public Result page(@RequestParam(defaultValue = "1") Integer page,
                       @RequestParam(defaultValue = "10") Integer pageSize,
                       String name, Short gender,
                       @DateTimeFormat(pattern = "yyyy-MM-dd") LocalDate begin,
                       @DateTimeFormat(pattern = "yyyy-MM-dd") LocalDate end) { // @DateTimeFormat 指定日期时间类型的格式
        log.info("分页查询，参数：{}, {}, {}, {}, {}, {}", page, pageSize, name, gender, begin, end);
        // 调用service分页查询
        PageBean pageBean = empService.page(page, pageSize, name, gender, begin, end);
        return Result.success(pageBean);
    }
}
```

+ EmpService.java

```java
package com.itfeng.service;

import com.itfeng.pojo.PageBean;

import java.time.LocalDate;

public interface EmpService {
    /**
     * 分页查询
     *
     * @param page
     * @param pageSize
     * @return
     */
    PageBean page(Integer page, Integer pageSize, String name, Short gender, LocalDate begin, LocalDate end);
}
```

+ EmpServiceImpl.java

```java
package com.itfeng.service.impl;

import com.github.pagehelper.Page;
import com.github.pagehelper.PageHelper;
import com.itfeng.mapper.EmpMapper;
import com.itfeng.pojo.Emp;
import com.itfeng.pojo.PageBean;
import com.itfeng.service.EmpService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.time.LocalDate;
import java.util.List;

@Service
public class EmpServiceImpl implements EmpService {

    @Autowired
    private EmpMapper empMapper;

//    @Override
//    public PageBean page(Integer page, Integer pageSize) {
//        // 1. 获取总记录数
//        Long count = empMapper.count();
//
//        // 2. 获取分页查询结果列表
//        Integer start = (page - 1) * pageSize;
//        List<Emp> empList = empMapper.page(start, pageSize);
//
//        // 3. 封装PageBean对象
//        PageBean pageBean = new PageBean(count, empList);
//        return pageBean;
//    }

    @Override
    public PageBean page(Integer page, Integer pageSize, String name, Short gender, LocalDate begin, LocalDate end) {

        // 1. 设置分页参数
        PageHelper.startPage(page, pageSize);

        // 2. 执行查询
        List<Emp> empList = empMapper.list(name, gender, begin, end);
        Page<Emp> p = (Page<Emp>) empList;

        // 3. 封装PageBean对象
        PageBean pageBean = new PageBean(p.getTotal(), p.getResult());
        return pageBean;
    }
}
```

+ EmpMapper.java

```java
package com.itfeng.mapper;

import com.itfeng.pojo.Emp;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Select;

import java.time.LocalDate;
import java.util.List;

/**
 * 员工管理
 */
@Mapper
public interface EmpMapper {

    /**
     * 查询总记录数
     *
     * @return
     */
//    @Select("select count(*) from emp;")
//    public Long count();

    /**
     * 分页查询，获取列表数据
     *
     * @param start
     * @param pageSize
     * @return
     */
//    @Select("select * from emp limit #{start}, #{pageSize};")
//    public List<Emp> page(Integer start, Integer pageSize);

    /**
     * 员工信息的查询
     */
//    @Select("select * from emp")
    public List<Emp> list(String name, Short gender, LocalDate begin, LocalDate end);
}
```

+ resources/com/itfeng/mapper/EmpMapper.xml

```java
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.itfeng.mapper.EmpMapper">

    <select id="list" resultType="com.itfeng.pojo.Emp">
        -- 条件查询
        select *
        from emp
        <where>
            <if test="name != null">
                name like concat('%', #{name}, '%')
            </if>
            <if test="gender != null">
                and gender = #{gender}
            </if>
            <if test="begin != null and end != null">
                and entrydate between #{begin} and #{end}
            </if>
        </where>
        order by update_time desc
    </select>

</mapper>
```

#### 小结

1. 条件分页查询

+ 条件查询：动态 SQL - XML 映射文件
+ 分页查询：PageHepler 分页插件



-------------------



### 3. 删除员工

<img src="./assets/image-20250810223426387.png" alt="image-20250810223426387" style="zoom:50%;" />

+ EmpController.java

```java
@DeleteMapping("/{ids}")
public Result delete(@PathVariable List<Integer> ids) {
    log.info("批量删除操作, ids:{}", ids);
    empService.delete(ids);
    return Result.success();
}
```

+ EmpService.java

```java
/**
 * 批量删除
 * @param ids
 */
void delete(List<Integer> ids);
```

+ EmpServiceImpl.java

```java
@Override
public void delete(List<Integer> ids) {
    empMapper.delete(ids);
}
```

+ EmpMapper.java

```java
/**
 * 批量删除
 * @param ids
 */
void delete(List<Integer> ids);
```

+ EmpMapper.xml

```xml
<!--    批量删除员工-->
<delete id="delete">
    delete
    from emp
    where id in
    <foreach collection="ids" item="id" separator="," open="(" close=")">
        #{id}
    </foreach>
</delete>
```



---------------------------------



### 4. 新增员工

<img src="./assets/image-20250814221232715.png" alt="image-20250814221232715" style="zoom:50%;" />

+ EmpController.java

```java
@PostMapping
public Result save(@RequestBody Emp emp){
    log.info("新增员工, emp：{}",emp);
    empService.save(emp);
    return Result.success();
}
```

+ EmpService.java

```java
/**
 * 新增员工
 * @param emp
 */
void save(Emp emp);
```

+ EmpServiceImpl.java

```java
@Override
public void save(Emp emp) {
    emp.setCreateTime(LocalDateTime.now());
    emp.setUpdateTime(LocalDateTime.now());
    empMapper.insert(emp);
}
```

+ EmpMapper.java

```java
/**
 * 新增员工
 * @param emp
 */
@Insert("insert into emp(username, name, gender, image, job, entrydate, dept_id, create_time, update_time) " +
        "values (#{username}, #{name}, #{gender}, #{image}, #{job}, #{entrydate}, #{deptId}, #{createTime}, #{updateTime})")
void insert(Emp emp);
```



------------------------------



### 5. 文件上传

#### 5.1 简介

+ 文件上传，是指将本地图片、视频、音频等文件上传到服务器，供其他用户浏览或下载的过程
+ 文件上传在项目中应用非常广泛，我们经常发微博、发微信朋友圈都用到了文件上传功能

前端页面三要素

```html
<form action="/upoad" method="post" enctype="multipart/form-data">
    姓名：<input type="text" name="username"><br>
    年龄：<input type="text" name="age"><br>
    头像：<input type="file" name="image"><br>
    <input type="submit" value="提交">
</form>
```

+ 表单中要定义一个表单项，类型为 file
+ 表单的提交方式为 POST
+ 表单的编码格式为 `multipart/form-data` （因为普通默认的编码格式不适合传输大型的二进制数据）

表单提交设置为此格式后，表单的数据在提交时将会分为多个部分进行提交，普通的表单数据可以正常提交，上传的文件名与内容都会提交到服务端

##### 代码实现

```java
package com.itfeng.controller;

import com.itfeng.pojo.Result;
import lombok.extern.slf4j.Slf4j;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.multipart.MultipartFile;

@Slf4j
@RestController
public class UploadController {

    @PostMapping("/upload")
    public Result upload(String username, Integer age, MultipartFile image) {
        log.info("文件上传：{}，{}，{}", username, age, image);
        return Result.success();
    }
}
```

##### 小结

1. 前端页面三要素

+ 表单项 type="file"
+ 表单提交方式 post
+ 表单的 enctype 属性 multipart/form-data

2. 服务端接收文件

+ MultipartFile



-----------------------



#### 5.2 本地存储

在项目开发中已经很少使用了

+ `String getOriginalFilename();` 获取原始文件名
+ `void transferTo(File dest);` 将接收的文件转存到磁盘文件中
+ `long getSize();` 获取文件的大小（单位：字节）
+ `byte[] getBytes();` 获取文件内容的字节数组
+ `InputStream getInputStream();` 获取接收到的文件内容的输入流

现在存储上传文件的方式：

+ 自己搭建一套文件存储服务来存储上传的文件
+ 使用别的公司提供的云服务来存储上传的文件



----------------------------



#### 5.3 阿里云 OSS

##### 5.3.1 阿里云

阿里云是阿里巴巴集团旗下全球领先的云计算公司，也是国内最大的云服务提供商

<img src="./assets/image-20250816195742709.png" alt="image-20250816195742709" style="zoom:50%;" />

##### 5.3.2 阿里云 OSS

阿里云对象存储 OSS（Object Storage Service），是一款海量、安全、低成本、高可靠的云存储服务。使用 OSS，你可以通过网络随时存储和调用包括文本、图片、音频和视频等在内的各种文件

<img src="./assets/image-20250816200021814.png" alt="image-20250816200021814" style="zoom:50%;" />

##### 5.3.3 第三方服务 - 通用思路

<img src="./assets/image-20250816200354080.png" alt="image-20250816200354080" style="zoom:50%;" />

1. 准备工作：完成一些账号的注册、实名认证，并登录到对应的后台来做一些基本的配置
2. 参照官方 SDK 编写入门程序

+ SDK：Software Development Kit 的缩写，软件开发工具包，包括辅助软件开发的依赖（jar 包）、代码示例等，都可以叫做 SDK

3. 集成使用，完成特定的业务功能

##### 5.3.4 阿里云 OSS - 使用步骤

<img src="./assets/image-20250816200457092.png" alt="image-20250816200457092" style="zoom:50%;" />

+ Bucket：存储空间是用户用于存储对象（Object，就是文件）的容器，所有的对象都必须隶属于某个存储空间

（1）打开https://www.aliyun.com/ ，申请阿里云账号并完成实名认证。

![image-20221128012526497](./assets/image-20221128012526497.png)  

（2）充值 (可以不用做)

（3）开通OSS

登录阿里云官网。 点击右上角的控制台。

![image-20221129214250389](./assets/image-20221129214250389.png) 

将鼠标移至产品，找到并单击对象存储OSS，打开OSS产品详情页面。在OSS产品详情页中的单击立即开通。

<img src="./assets/image-20221129214332892.png" alt="image-20221129214332892" style="zoom:67%;" /> 

<img src="./assets/image-20221129214403131.png" alt="image-20221129214403131" style="zoom:80%;" /> 

![image-20221128012258544](./assets/image-20221128012258544.png) 



开通服务后，在OSS产品详情页面单击管理控制台直接进入OSS管理控制台界面。您也可以单击位于官网首页右上方菜单栏的控制台，进入阿里云管理控制台首页，然后单击左侧的对象存储OSS菜单进入[OSS管理控制台界面](https://oss.console.aliyun.com/overview)。

![image-20201126234535040](./assets/image-20201126234535040.png)

（4）创建存储空间

新建Bucket，命名为 hmleadnews ，读写权限为 **==公共读==**

<img src="./assets/image-20250816201437555.png" alt="image-20250816201437555" style="zoom:50%;" />

<img src="./assets/image-20250816201802860.png" alt="image-20250816201802860" style="zoom:50%;" />

（5）获取 AccessKey（秘钥）

<img src="./assets/image-20250816202244927.png" alt="image-20250816202244927" style="zoom:50%;" />

<img src="./assets/image-20250816202622905.png" alt="image-20250816202622905" style="zoom:50%;" />

  （6）参照官方 SDK 编写入门程序

<img src="./assets/image-20250817112157629.png" alt="image-20250817112157629" style="zoom:50%;" />

<img src="./assets/image-20250817114416843.png" alt="image-20250817114416843" style="zoom:50%;" />

+ 成功则如下所示

<img src="./assets/image-20250817195908618.png" alt="image-20250817195908618" style="zoom:50%;" />



----------------------



#### 5.4 阿里云 OSS - 集成

<img src="./assets/image-20250817200449735.png" alt="image-20250817200449735" style="zoom:50%;" />

步骤：

1. 引入阿里云 OSS 上传文件工具类（由官方的示例代码改造而来）
2. 上传图片接口开发

##### 5.4.1 阿里云文件上传工具类

```java
package com.itfeng.utils;

import com.aliyun.oss.*;
import com.aliyun.oss.common.auth.*;
import com.aliyun.oss.common.comm.SignVersion;
import com.aliyun.oss.model.PutObjectRequest;
import com.aliyun.oss.model.PutObjectResult;
import org.springframework.stereotype.Component;
import org.springframework.web.multipart.MultipartFile;
import java.io.InputStream;
import java.util.UUID;

@Component
public class AliOSSUtils {

    public String upload(MultipartFile file) throws Exception {

        // 避免文件覆盖
        String originalFilename = file.getOriginalFilename();
        String fileName = UUID.randomUUID().toString() + originalFilename.substring(originalFilename.lastIndexOf("."));

        // Endpoint以华东1（杭州）为例，其它Region请按实际情况填写。
        String endpoint = "https://oss-cn-hangzhou.aliyuncs.com";
        // 从环境变量中获取访问凭证。运行本代码示例之前，请确保已设置环境变量OSS_ACCESS_KEY_ID和OSS_ACCESS_KEY_SECRET。
        EnvironmentVariableCredentialsProvider credentialsProvider = CredentialsProviderFactory.newEnvironmentVariableCredentialsProvider();
        // 填写Bucket名称，例如examplebucket。
        String bucketName = "web-xfengx";
        // 填写本地文件的完整路径，例如D:\\localpath\\examplefile.txt。
        // 填写Bucket所在地域。以华东1（杭州）为例，Region填写为cn-hangzhou。
        String region = "cn-hangzhou";

        // 创建OSSClient实例。
        // 当OSSClient实例不再使用时，调用shutdown方法以释放资源。
        ClientBuilderConfiguration clientBuilderConfiguration = new ClientBuilderConfiguration();
        clientBuilderConfiguration.setSignatureVersion(SignVersion.V4);
        OSS ossClient = OSSClientBuilder.create()
                .endpoint(endpoint)
                .credentialsProvider(credentialsProvider)
                .clientConfiguration(clientBuilderConfiguration)
                .region(region)
                .build();

        try {
            // 使用MultipartFile的getInputStream()方法获取输入流
            InputStream inputStream = file.getInputStream();
            // 创建PutObjectRequest对象。
            PutObjectRequest putObjectRequest = new PutObjectRequest(bucketName, fileName, inputStream);
            // 创建PutObject请求。
            PutObjectResult result = ossClient.putObject(putObjectRequest);
        } catch (OSSException oe) {
            System.out.println("Caught an OSSException, which means your request made it to OSS, "
                    + "but was rejected with an error response for some reason.");
            System.out.println("Error Message:" + oe.getErrorMessage());
            System.out.println("Error Code:" + oe.getErrorCode());
            System.out.println("Request ID:" + oe.getRequestId());
            System.out.println("Host ID:" + oe.getHostId());
        } catch (ClientException ce) {
            System.out.println("Caught an ClientException, which means the client encountered "
                    + "a serious internal problem while trying to communicate with OSS, "
                    + "such as not being able to access the network.");
            System.out.println("Error Message:" + ce.getMessage());
        } finally {
            if (ossClient != null) {
                ossClient.shutdown();
            }
        }
        //文件访问路径
        String url = endpoint.split("//")[0] + "//" + bucketName + "." + endpoint.split("//")[1] + "/" + fileName;
        return url;// 把上传到oss的路径返回
    }
}
```

#### 小结

1. 文件上传介绍
2. 前端页面三要素（file 表单项、post 方式、multipart / form-data）
3. 服务端接收文件（MultipartFile）
4. 文件存储方式



-----------------------



### 6. 修改员工

#### 6.1 查询回显

<img src="./assets/image-20250817215819556.png" alt="image-20250817215819556" style="zoom:50%;" />

#####  代码实现

+ EmpController.java

```java
@GetMapping("{id}")
public Result getById(@PathVariable Integer id) {
    log.info("根据ID查询员工信息，id：{}", id);
    Emp emp = empService.getById(id);
    return Result.success(emp);
}
```

+ EmpService.java

```java
/**
 * 根据ID查询员工
 * @param id
 * @return
 */
Emp getById(Integer id);
```

+ EmpServiceImpl.java

```java
@Override
public Emp getById(Integer id) {
    return empMapper.getById(id);
}
```

+ EmpMapper.java

```java
/**
 * 根据ID查询员工
 * @param id
 * @return
 */
@Select("select * from emp where id = #{id}")
Emp getById(Integer id);
```



----------------------



#### 6.2 修改员工

<img src="./assets/image-20250817221320611.png" alt="image-20250817221320611" style="zoom:50%;" />

##### 代码实现

+ EmpController.java

```java
@PutMapping
public Result update(@RequestBody Emp emp) {
    log.info("更新员工信息：{}", emp);
    empService.update(emp);
    return Result.success();
}
```

+ EmpService.java

```java
/**
 * 更新员工
 * @param emp
 */
void update(Emp emp);
```

+ EmpServiceImpl.java

```java
@Override
public void update(Emp emp) {
    emp.setUpdateTime(LocalDateTime.now());

    empMapper.update(emp);
}
```

+ EmpMapper.java

```java
/**
 * 更新员工
 * @param emp
 */
void update(Emp emp);
```

+ EmpMapper.xml

```xml
<!--    更新员工-->
    <update id="update">
        update emp
        <set>
            <if test="username != null and username != ''">
                username = #{username},
            </if>
            <if test="password != null and password != ''">
                password = #{password},
            </if>
            <if test="name != null and name != ''">
                name = #{name},
            </if>
            <if test="gender != null">
                gender = #{gender},
            </if>
            <if test="image != null and image != ''">
                image = #{image},
            </if>
            <if test="job != null and job != ''">
                job = #{job},
            </if>
            <if test="entrydate != null">
                entrydate = #{entrydate},
            </if>
            <if test="deptId != null">
                dept_id = #{deptId},
            </if>
            <if test="updateTime != null">
                update_time = #{updateTime}
            </if>
        </set>
        where id = #{id};
    </update>
```



---------------------



### 7. 配置文件

#### 7.1 参数配置化

之前的代码中有很多参数不变维护及管理

+ 问题解决
  + `@Value` 注解通常用于外部配置的属性注入，具体用法为：`@Value("${配置文件中的key}")`

<img src="./assets/image-20250817231605330.png" alt="image-20250817231605330" style="zoom:50%;" />

##### 代码演示

+ application.properties

```pro
# 阿里云OSS配置
aliyun.oss.endpoint=https://oss-cn-hangzhou.aliyuncs.com
aliyun.oss.bucketName=自己的bucketName
aliyun.oss.region=cn-hangzhou
```

+ AliOSSUtils.java

```java
package com.itfeng.utils;

import com.aliyun.oss.*;
import com.aliyun.oss.common.auth.*;
import com.aliyun.oss.common.comm.SignVersion;
import com.aliyun.oss.model.PutObjectRequest;
import com.aliyun.oss.model.PutObjectResult;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;
import org.springframework.web.multipart.MultipartFile;

import java.io.InputStream;
import java.util.UUID;

@Component
public class AliOSSUtils {
    // Endpoint以华东1（杭州）为例，其它Region请按实际情况填写。
    @Value("${aliyun.oss.endpoint}")
    private String endpoint;

    // 填写Bucket名称，例如examplebucket。
    @Value("${aliyun.oss.bucketName}")
    private String bucketName;
    
    // 填写Bucket所在地域。以华东1（杭州）为例，Region填写为cn-hangzhou。
    @Value("${aliyun.oss.region}")
    private String region = "cn-hangzhou";

    public String upload(MultipartFile file) throws Exception {

        // 避免文件覆盖
        String originalFilename = file.getOriginalFilename();
        String fileName = UUID.randomUUID().toString() + originalFilename.substring(originalFilename.lastIndexOf("."));


        // 从环境变量中获取访问凭证。运行本代码示例之前，请确保已设置环境变量OSS_ACCESS_KEY_ID和OSS_ACCESS_KEY_SECRET。
        EnvironmentVariableCredentialsProvider credentialsProvider = CredentialsProviderFactory.newEnvironmentVariableCredentialsProvider();

        // 创建OSSClient实例。
        // 当OSSClient实例不再使用时，调用shutdown方法以释放资源。
        ClientBuilderConfiguration clientBuilderConfiguration = new ClientBuilderConfiguration();
        clientBuilderConfiguration.setSignatureVersion(SignVersion.V4);
        OSS ossClient = OSSClientBuilder.create()
                .endpoint(endpoint)
                .credentialsProvider(credentialsProvider)
                .clientConfiguration(clientBuilderConfiguration)
                .region(region)
                .build();

        try {
            // 使用MultipartFile的getInputStream()方法获取输入流
            InputStream inputStream = file.getInputStream();
            // 创建PutObjectRequest对象。
            PutObjectRequest putObjectRequest = new PutObjectRequest(bucketName, fileName, inputStream);
            // 创建PutObject请求。
            PutObjectResult result = ossClient.putObject(putObjectRequest);
        } catch (OSSException oe) {
            System.out.println("Caught an OSSException, which means your request made it to OSS, "
                    + "but was rejected with an error response for some reason.");
            System.out.println("Error Message:" + oe.getErrorMessage());
            System.out.println("Error Code:" + oe.getErrorCode());
            System.out.println("Request ID:" + oe.getRequestId());
            System.out.println("Host ID:" + oe.getHostId());
        } catch (ClientException ce) {
            System.out.println("Caught an ClientException, which means the client encountered "
                    + "a serious internal problem while trying to communicate with OSS, "
                    + "such as not being able to access the network.");
            System.out.println("Error Message:" + ce.getMessage());
        } finally {
            if (ossClient != null) {
                ossClient.shutdown();
            }
        }
        //文件访问路径
        String url = endpoint.split("//")[0] + "//" + bucketName + "." + endpoint.split("//")[1] + "/" + fileName;
        return url;// 把上传到oss的路径返回
    }
}
```



-------------



#### 7.2 yml 配置文件

##### 7.2.1 配置格式

+ SpringBoot 提供了多种属性配置方式

  + application.**properties**

  ```properties
  server.prot=8080
  server.adress=127.0.0.1
  ```

  + application.**yml**

  ```yml
  server
  	port: 8080
  	address: 127.0.0.1
  ```

  + application.**yaml**

  ```yaml
  server
  	port: 8080
  	address: 127.0.0.1
  ```

+ 常见配置文件格式对比

  + XML

  ```xml
  <server>
  	<port>8080</port>
      <address>127.0.0.1</address>
  </server>
  ```

  + properties

  ```properties
  server.prot=8080
  server.adress=127.0.0.1
  ```

  + yml / yaml

  ```yaml
  server
  	port: 8080
  	address: 127.0.0.1
  ```

##### 7.2.2 yml

基本语法

+ 大小写敏感
+ 数值前边必须有空格，作为分隔符
+ 使用缩进表示层级关系，缩进时，不允许使用 Tab 键，只能用空格（idea 中会自动将 Tab 转换为空格）
+ 缩进的空格数目不重要，只要相同层级的元素左侧对齐即可
+ `#` 表示注释，从这个字符一直到尾行，都会被解析器忽略

##### 7.2.3 yml 数据格式

+ 对象 / Map 集合：

```yaml
user:
  name: zhangsan
  age: 18
  password: 123456
```

+ 数组 / List / Set 集合：

``` yaml
hobby:
  - java
  - game
  - sport
```

##### 7.2.4 yml 配置

+ 在 application.yml 中配置案例相关的配置项

```yaml
spring:
  # 数据库连接信息
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/tlias
    username: root
    password: 1234
  # 文件上传配置
  servlet:
    multipart:
      # 单个文件最大大小
      max-file-size: 10MB
      # 总的请求大小
      max-request-size: 100MB
# Mybatis配置
mybatis:
  configuration:
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
    map-underscore-to-camel-case: true

# 阿里云OSS
aliyun:
  oss:
    endpoint: https://oss-cn-hangzhou.aliyuncs.com
    bucketName: 自己的bucketName
    region: cn-hangzhou
```



------------------



#### 7.3 @ConfigurationProperties

直接将配置文件中配置项的值自动地注入到对象的属性中

+ 引入依赖

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-configuration-processor</artifactId>
</dependency>
```

+ AliOSSProperties.java

```java
package com.itfeng.utils;

import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

@Data
@Component
@ConfigurationProperties(prefix="aliyun.oss")
public class AliOSSProperties {
    private String endpoint;
    private String bucketName;
    private String region;
}
```

+ AliOSSUtils.java

```java
package com.itfeng.utils;

import com.aliyun.oss.*;
import com.aliyun.oss.common.auth.*;
import com.aliyun.oss.common.comm.SignVersion;
import com.aliyun.oss.model.PutObjectRequest;
import com.aliyun.oss.model.PutObjectResult;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.web.multipart.MultipartFile;

import java.io.InputStream;
import java.util.UUID;

@Component
public class AliOSSUtils {
    //    // Endpoint以华东1（杭州）为例，其它Region请按实际情况填写。
//    @Value("${aliyun.oss.endpoint}")
//    private String endpoint;
//
//    // 填写Bucket名称，例如examplebucket。
//    @Value("${aliyun.oss.bucketName}")
//    private String bucketName;
//
//    // 填写Bucket所在地域。以华东1（杭州）为例，Region填写为cn-hangzhou。
//    @Value("${aliyun.oss.region}")
//    private String region = "cn-hangzhou";

    @Autowired
    private AliOSSProperties aliOSSProperties;

    /**
     * 实现上传图片到OSS
     *
     * @param file
     * @return
     * @throws Exception
     */
    public String upload(MultipartFile file) throws Exception {

        // 获取阿里云OSS参数
        String endpoint = aliOSSProperties.getEndpoint();
        String bucketName = aliOSSProperties.getBucketName();
        String region = aliOSSProperties.getRegion();

        // 避免文件覆盖
        String originalFilename = file.getOriginalFilename();
        String fileName = UUID.randomUUID().toString() + originalFilename.substring(originalFilename.lastIndexOf("."));

        // 从环境变量中获取访问凭证。运行本代码示例之前，请确保已设置环境变量OSS_ACCESS_KEY_ID和OSS_ACCESS_KEY_SECRET。
        EnvironmentVariableCredentialsProvider credentialsProvider = CredentialsProviderFactory.newEnvironmentVariableCredentialsProvider();

        // 创建OSSClient实例。
        // 当OSSClient实例不再使用时，调用shutdown方法以释放资源。
        ClientBuilderConfiguration clientBuilderConfiguration = new ClientBuilderConfiguration();
        clientBuilderConfiguration.setSignatureVersion(SignVersion.V4);
        OSS ossClient = OSSClientBuilder.create()
                .endpoint(endpoint)
                .credentialsProvider(credentialsProvider)
                .clientConfiguration(clientBuilderConfiguration)
                .region(region)
                .build();

        try {
            // 使用MultipartFile的getInputStream()方法获取输入流
            InputStream inputStream = file.getInputStream();
            // 创建PutObjectRequest对象。
            PutObjectRequest putObjectRequest = new PutObjectRequest(bucketName, fileName, inputStream);
            // 创建PutObject请求。
            PutObjectResult result = ossClient.putObject(putObjectRequest);
        } catch (OSSException oe) {
            System.out.println("Caught an OSSException, which means your request made it to OSS, "
                    + "but was rejected with an error response for some reason.");
            System.out.println("Error Message:" + oe.getErrorMessage());
            System.out.println("Error Code:" + oe.getErrorCode());
            System.out.println("Request ID:" + oe.getRequestId());
            System.out.println("Host ID:" + oe.getHostId());
        } catch (ClientException ce) {
            System.out.println("Caught an ClientException, which means the client encountered "
                    + "a serious internal problem while trying to communicate with OSS, "
                    + "such as not being able to access the network.");
            System.out.println("Error Message:" + ce.getMessage());
        } finally {
            if (ossClient != null) {
                ossClient.shutdown();
            }
        }
        //文件访问路径
        String url = endpoint.split("//")[0] + "//" + bucketName + "." + endpoint.split("//")[1] + "/" + fileName;
        return url;// 把上传到oss的路径返回
    }
}
```



---------------------



## 四、登录认证

### 1. 登录功能

<img src="./assets/image-20250819210158074.png" alt="image-20250819210158074" style="zoom:50%;" />

+ LoginController.java

```java
package com.itfeng.controller;

import com.itfeng.pojo.Emp;
import com.itfeng.pojo.Result;
import com.itfeng.service.EmpService;
import lombok.extern.slf4j.Slf4j;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;

//@Slf4j
@RestController
public class LoginController {

    private static Logger log = LoggerFactory.getLogger(LoginController.class);

    @Autowired
    private EmpService empService;

    @PostMapping("/login")
    public Result login(@RequestBody Emp emp) {
        log.info("员工登录：{}", emp);
        Emp e = empService.login(emp);
        return e != null ? Result.success(e) : Result.error("用户名或密码错误");
    }
}
```

+ EmpService.java

```java
/**
 * 登录
 *
 * @param emp
 */
Emp login(Emp emp);
```

+ EmpServiceImpl.java

```java
@Override
public Emp login(Emp emp) {
    return empMapper.getByUsernameAndPassword(emp);
}
```

+ EmpMapper.java

```java
/**
 * 根据用户名和密码查询员工
 * @param emp
 * @return
 */
@Select("select * from emp where username = #{username} and password = #{password}")
Emp getByUsernameAndPassword(Emp emp);
```



-------------------------



### 2. 登录校验

问题：当前在未登录情况下，我们也可以直接访问部门管理、员工管理等功能

<img src="./assets/image-20250819212315638.png" alt="image-20250819212315638" style="zoom:50%;" />

+ 登录标记
  + 用户登录成功之后，每一次请求中，都可以获取到该标记

+ 统一拦截
  + 过滤器 Filter
  + 拦截器 Interceptor

#### 2.1 会话技术

+ 会话：用户打开浏览器，访问 web 服务器的资源，会话建立，直到有一方断开连接，会话结束。有一次会话中可以包含**多次**请求和响应
+ 会话跟踪：一种维护浏览器状态的方法，服务器需要识别多次请求是否来自于同一浏览器，以便在同一次会话的多次请求间**共享数据**
+ 会话跟踪方案：
  + 客户端会话跟踪技术：Cookie
  + 服务端会话跟踪技术：Session
  + 令牌技术

#### 2.2 会话跟踪方案对比

##### 方案一：Cookie

存储在客户端浏览器的，使用 Cookie 来跟踪会话，我们就可以在浏览器第一次发起请求来请求服务器的时候设置一个 Cookie，就可以在 Cookie 中存储一些数据信息。服务器端在响应数据的时候会自动将这个 Cookie 响应给浏览器，浏览器接收到后，会自动的将这个 Cookie 值存储在浏览器本地。接下来在每一次请求中都会将浏览器本地所存储的 Cookie 自动的携带到服务端

+ 优点：HTTP 协议中支持的技术
+ 缺点
  + 移动端 APP 无法使用 Cookie
  + 不安全，用户可以自己禁用 Cookie
  + Cookie 不能跨域

<img src="./assets/image-20250819213849772.png" alt="image-20250819213849772" style="zoom:50%;" />

跨域：前后端程序部署在不同的协议、IP/域名、端口上

<img src="./assets/image-20250819214428335.png" alt="image-20250819214428335" style="zoom:50%;" />

##### 方案二：Session

每个 Session 都有个 ID，将 Session 的 ID 作为 Cookie 的值来传递，服务器拿到 Session 的 ID 之后就从众多 Session 当中找到当前请求对应的会话对象 Session

<img src="./assets/image-20250819214957980.png" alt="image-20250819214957980" style="zoom: 50%;" />

+ 优点：存储在服务端，安全
+ 缺点
  + 服务器集群环境下无法直接使用 Session
  + Cookie 的缺点

##### 方案三：令牌技术

在浏览器发起请求，在请求登录接口的时候，如果登陆成功就可以生成一个令牌，这个令牌就是这个用户的合法身份凭证，接下来在响应数据的时候就可以直接将这个令牌响应给前端。前端程序接收到之后就将其存储起来，接下来在每一次请求当中，都需要将这个令牌携带到服务端。然后校验这个令牌的有效性，如果这个令牌是有效的就说明用户已经执行了登陆操作，如果想共享数据，就将共享的数据存储在这个令牌当中就可以了

<img src="./assets/image-20250819215553639.png" alt="image-20250819215553639" style="zoom:50%;" />

+ 优点
  + 支持 PC 端、移动端
  + 解决集群环境下的认证问题
  + 减轻服务器端存储压力
+ 缺点：需要自己实现



---------------------------------



#### 2.2 JWT 令牌

##### 2.2.1 简介

+ 全称：JSON Web Token（[JSON Web Tokens - jwt.io](https://www.jwt.io/)）
+ 定义了一种简洁的、自包含的格式，用于在通信双方以 json 数据格式安全的传输信息。由于数字签名的存在，这些信息是可靠的

+ 组成
  + 第一部分：Header（头），记录令牌类型、签名算法等。例如：{"alg":"HS256","type":"JWT"}	后续进行 Base64 编码
  + 第二部分：Payload（有效载荷），携带一些自定义信息、默认信息等。例如：{"id":"1","username":"Tom"}        进行 Base64 编码
  + 第三部分：Signature（签名），防止 Token 被篡改、确保安全性。将 header、payload，并加入指定秘钥，通过指定签名算法计算而来

<img src="./assets/image-20250819220558315.png" alt="image-20250819220558315" style="zoom:50%;" />

Base64：是一种基于64个可打印字符（A-Z a-z 0-9 + /）来表示二进制数据的编码方式

+ 应用场景：登录认证

1. 登录成功后，生成令牌

2. 后续每个请求，都要携带 JWT 令牌，系统在每次请求处理之前，先校验令牌，通过后，再处理

##### 2.2.2 JWT - 生成

+ 引入依赖

```xml
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt</artifactId>
    <version>0.12.6</version>
</dependency>
```

+ 生成令牌

```java
/**
 * 生成JWT
 */
@Test
public void testGenJwt() {
    Map<String, Object> claims = new HashMap<>();
    claims.put("id", 1);
    claims.put("name", "Tom");

    String jwt = Jwts.builder()
            .signWith(SignatureAlgorithm.HS256, "itfengfnaknfnsjbfklagfaslhfkjaewkhfluiwaehilfhawuigfawhighawiulfhahfiulhwakfhiawlhf") // 签名算法
            .setClaims(claims) // 自定义内容（载荷）
            .setExpiration(new Date(System.currentTimeMillis() + 3600 * 1000)) // 设置有效期为一个小时
            .compact();
    System.out.println(jwt);
}
```

<img src="./assets/image-20250819222213613.png" alt="image-20250819222213613" style="zoom:50%;" />

+ 解析令牌

```java
/**
 * 解析jwt令牌
 */
@Test
public void testParseJwt() {
    Claims claims = Jwts.parser()
            .setSigningKey("itfengfnaknfnsjbfklagfaslhfkjaewkhfluiwaehilfhawuigfawhighawiulfhahfiulhwakfhiawlhf") // 指定签名秘钥
            .build().parseClaimsJws("eyJhbGciOiJIUzI1NiJ9.eyJuYW1lIjoiVG9tIiwiaWQiOjEsImV4cCI6MTc1NTYxNjg1M30.sJ1AbttD27moXUU6LDTVzg8I52JUZ5C7DbucdX82XRo") // 解析令牌
            .getBody();
    System.out.println(claims);
}
```

注意事项：

+ JWT 校验时使用的签名秘钥，必须和生成 JWT 令牌时使用的秘钥是配套的
+ 如果 JWT 令牌解析校验时报错，则说明 JWT 令牌被篡改或失效了，令牌非法



##### 2.2.3 登录后下发令牌

思路：

+ 令牌生成：登陆成功后，生成 JWT 令牌，并返回给前端
+ 令牌校验：在请求到达服务端后，对令牌进行统一拦截、校验

步骤

+ 引入 JWT 令牌操作工具类
+ 登录完成后，调用工具类生成 JWT 令牌，并返回

工具类

+ JwtUtils.java

```java
package com.itfeng.utils;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;

import java.util.Date;
import java.util.Map;

public class JwtUtils {

    private static String signKey = "itfengiujauhfuahifnansfihaifajofjmlmfinjwqnuifnaknmfnawuklfaklnfmqoimam,";
    private static Long expire = 43200000L;

    /**
     * 生成JWT令牌
     *
     * @param claims JWT第二部分负载 payload 中存储的内容
     * @return
     */
    public static String generateJwt(Map<String, Object> claims) {
        String jwt = Jwts.builder()
                .addClaims(claims)
                .signWith(SignatureAlgorithm.HS256, signKey)
                .setExpiration(new Date(System.currentTimeMillis() + expire))
                .compact();
        return jwt;
    }

    /**
     * 解析JWT令牌
     *
     * @param jwt JWT令牌
     * @return JWT第二部分负载 payload 中存储的内容
     */
    public static Claims parseJWT(String jwt) {
        Claims claims = Jwts.parser()
                .setSigningKey(signKey)
                .build()
                .parseClaimsJws(jwt)
                .getBody();
        return claims;
    }
}
```

+ LoginController.java

```java
package com.itfeng.controller;

import com.itfeng.pojo.Emp;
import com.itfeng.pojo.Result;
import com.itfeng.service.EmpService;
import com.itfeng.utils.JwtUtils;
import lombok.extern.slf4j.Slf4j;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;

import java.util.HashMap;
import java.util.Map;

//@Slf4j
@RestController
public class LoginController {

    private static Logger log = LoggerFactory.getLogger(LoginController.class);

    @Autowired
    private EmpService empService;

    @PostMapping("/login")
    public Result login(@RequestBody Emp emp) {
        log.info("员工登录：{}", emp);
        Emp e = empService.login(emp);

        // 登陆成功，生成令牌，下发令牌
        if (e != null) {
            Map<String, Object> claims = new HashMap<>();
            claims.put("id", e.getId());
            claims.put("name", e.getName());
            claims.put("username", e.getUsername());

            String jwt = JwtUtils.generateJwt(claims); // jwt包含了当前登陆的员工信息
            return Result.success(jwt);
        }

        // 登录失败，返回错误信息
        return Result.error("用户名或密码错误");
    }
}
```



----------------------------------



#### 2.3 过滤器 Filter

##### 2.3.1 快速入门

概述

+ 概念：**Filter 过滤器**，是 JavaWeb 三大组件（Servlet、Filter、Listener）之一
+ 过滤器可以把对资源的请求**拦截**下来，从而实现一些特殊的功能
+ 过滤器一般完成一些**通用**的操作，比如：登录校验、统一编码处理、敏感字符处理等

>1. 定义 Filter：定义一个类，实现 Filter 接口，并重写其所有方法
>2. 配置 Filter：Filter 类上加 `@WebFilter` 注解，配置拦截资源的路径。引导类上加 `@ServletComponentScan` 开启 Servlet 组件支持

```java
package com.itfeng.filter;

import jakarta.servlet.*;
import jakarta.servlet.annotation.WebFilter;

import java.io.IOException;

@WebFilter(urlPatterns = "/*")
public class DemoFilter implements Filter {
    @Override // 初始化方法，只调用一次
    public void init(FilterConfig filterConfig) throws ServletException {
        System.out.println("init 初始化方法执行了");
    }

    @Override // 拦截到请求之后调用，调用多次
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        System.out.println("拦截到了请求");
        // 放行
        filterChain.doFilter(servletRequest, servletResponse);
    }

    @Override // 销毁方法，只调用一次
    public void destroy() {
        System.out.println("destroy 销毁方法执行了");
    }
}
```

###### 小结

1. Filter 快速入门

+ 定义：实现 Filter 接口
+ 配置：
  + `@WebFilter(urlPatterns="/*")`
  + `@ServletComponentScan`



----------------



##### 2.3.2 详解（执行流程、拦截路径、过滤器链）

###### 2.3.2.1 执行流程

放行后访问对应资源，资源访问完成后会回到 Filter 中

回到 Filter 中，只执行放行后的逻辑

###### 2.3.2.2 Filter 拦截路径

+ Filter 可以根据需求，配置不同的拦截资源路径

| 拦截路径     | urlPatterns 值 | 含义                                |
| ------------ | -------------- | ----------------------------------- |
| 拦截具体路径 | /login         | 只有访问 /login 路径时，才会被拦截  |
| 目录拦截     | /emps/*        | 访问 /emps 下所有的资源，都会被拦截 |
| 拦截所有     | /*             | 访问所有资源，都会被拦截            |

###### 2.3.2.3 过滤器链

+ 介绍：一个 web 应用中，可以配置多个过滤器，这多个过滤器就形成了一个**过滤器链**
+ 顺序：注解配置的 Filter，优先级是按照过滤器类名（字符串）的自然顺序

<img src="./assets/image-20250820213317699.png" alt="image-20250820213317699" style="zoom:50%;" />

###### 小结

1. 执行流程

+ 请求 --> 放行前逻辑 --> 放行 --> 资源 --> 放行后逻辑

2. 拦截路径

+ /login
+ /depts/*
+ /*

3. 过滤器链

+ 一个 web 应用中，配置了多个过滤器，就形成了一个过滤器链



------------------------



##### 2.3.3 登录校验-Filter

1. 获取请求 url
2. 判断请求 url 中是否包含 login，如果包含，说明是登录操作，放行
3. 获取请求头中的令牌（token）
4. 判断令牌是否存在，如果不存在，返回错误结果（未登录）
5. 解析 token，如果解析失败，返回错误结果（未登录）
6. 放行

阿里巴巴 fastJSON 工具包，JSON 格式转换工具包

+ pom.xml

```xml
<!-- fastJSON-->
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>fastjson</artifactId>
    <version>1.2.83</version>
</dependency>
```

+ LoginCheckFilter.java

```java
package com.itfeng.filter;

import com.alibaba.fastjson.JSONObject;
import com.itfeng.pojo.Result;
import com.itfeng.utils.JwtUtils;
import jakarta.servlet.*;
import jakarta.servlet.annotation.WebFilter;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.extern.slf4j.Slf4j;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.util.StringUtils;

import java.io.IOException;

//@Slf4j
@WebFilter(urlPatterns = "/*")
public class LoginCheckFilter implements Filter {

    private static Logger log = LoggerFactory.getLogger(LoginCheckFilter.class);

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        HttpServletRequest req = (HttpServletRequest) servletRequest; // 因为tomcat传入的request实际上是HTTPRequest  这里是多态的思想
        HttpServletResponse resp = (HttpServletResponse) servletResponse;

        // 1. 获取请求url
        String url = req.getRequestURI().toString();
        log.info("请求的url：{}", url);

        // 2. 判断请求url中是否包含login，如果包含，说明是登录操作，放行
        if (url.contains("login")) {
            log.info("登录操作，放行...");
            filterChain.doFilter(servletRequest, servletResponse);
            return;
        }

        // 3. 获取请求头中的令牌（token）
        String jwt = req.getHeader("token");

        // 4. 判断令牌是否存在，如果不存在，返回错误结果（未登录）
        if (!StringUtils.hasLength(jwt)) {
            log.info("请求头token为空，返回未登录的信息");
            Result error = Result.error("NOT_LOGIN");
            // 手动转换，对象--json ----------> 阿里巴巴fastJSON工具包
            String notLogin = JSONObject.toJSONString(error);
            resp.getWriter().write(notLogin); // 获取输出流
            return;
        }

        // 5. 解析 token，如果解析失败，返回错误结果（未登录）
        try {
            JwtUtils.parseJWT(jwt);
        } catch (Exception e) { // jwt解析失败
            e.printStackTrace();
            log.info("解析令牌失败，返回登录错误信息");
            Result error = Result.error("NOT_LOGIN");
            // 手动转换，对象--json ----------> 阿里巴巴fastJSON工具包
            String notLogin = JSONObject.toJSONString(error);
            resp.getWriter().write(notLogin); // 获取输出流
            return;
        }

        // 6. 放行
        log.info("令牌合法，放行");
        filterChain.doFilter(servletRequest, servletResponse);
    }
}
```



------------------------------



##### 补充

```java
// 1. 创建可缓存请求的Wrapper
public class CachedBodyHttpServletRequest extends HttpServletRequestWrapper {
    private byte[] cachedBody;

    public CachedBodyHttpServletRequest(HttpServletRequest request) throws IOException {
        super(request);
        InputStream requestInputStream = request.getInputStream();
        this.cachedBody = StreamUtils.copyToByteArray(requestInputStream);
    }

    @Override
    public ServletInputStream getInputStream() throws IOException {
        return new CachedBodyServletInputStream(this.cachedBody);
    }

    @Override
    public BufferedReader getReader() throws IOException {
        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(this.cachedBody);
        return new BufferedReader(new InputStreamReader(byteArrayInputStream));
    }
}

// 2. 自定义ServletInputStream
public class CachedBodyServletInputStream extends ServletInputStream {
    private InputStream cachedBodyInputStream;

    public CachedBodyServletInputStream(byte[] cachedBody) {
        this.cachedBodyInputStream = new ByteArrayInputStream(cachedBody);
    }

    @Override
    public boolean isFinished() {
        try {
            return cachedBodyInputStream.available() == 0;
        } catch (IOException e) {
            return false;
        }
    }

    @Override
    public boolean isReady() {
        return true;
    }

    @Override
    public void setReadListener(ReadListener listener) {
        throw new UnsupportedOperationException();
    }

    @Override
    public int read() throws IOException {
        return cachedBodyInputStream.read();
    }
}

// 3. 实现过滤器
@Component
@Order(1)
public class RequestLoggingFilter implements Filter {

    private static final Logger LOG = LoggerFactory.getLogger(RequestLoggingFilter.class);

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) 
            throws IOException, ServletException {
        
        HttpServletRequest httpServletRequest = (HttpServletRequest) request;
        CachedBodyHttpServletRequest cachedBodyRequest = new CachedBodyHttpServletRequest(httpServletRequest);
        
        // 记录请求信息
        logRequestInfo(cachedBodyRequest);
        
        chain.doFilter(cachedBodyRequest, response);
    }

    private void logRequestInfo(CachedBodyHttpServletRequest request) throws IOException {
        StringBuilder info = new StringBuilder();
        info.append("\n=== HTTP请求信息 ===\n");
        
        // 请求方法、URL和协议
        info.append("Method: ").append(request.getMethod()).append("\n");
        info.append("URL: ").append(request.getRequestURL()).append("\n");
        info.append("Protocol: ").append(request.getProtocol()).append("\n");
        
        // 请求头
        info.append("Headers:\n");
        Enumeration headerNames = request.getHeaderNames();
        while (headerNames.hasMoreElements()) {
            String headerName = headerNames.nextElement();
            info.append("  ").append(headerName).append(": ")
                .append(request.getHeader(headerName)).append("\n");
        }
        
        // 请求参数
        info.append("Parameters:\n");
        Map parameterMap = request.getParameterMap();
        for (Map.Entry entry : parameterMap.entrySet()) {
            info.append("  ").append(entry.getKey()).append(": ")
                .append(Arrays.toString(entry.getValue())).append("\n");
        }
        
        // 请求体
        String requestBody = StreamUtils.copyToString(request.getInputStream(), 
                StandardCharsets.UTF_8);
        if (!requestBody.isEmpty()) {
            info.append("Body: ").append(requestBody).append("\n");
        }
        
        info.append("===================");
        LOG.info(info.toString());
    }
}
```



------------------



#### 2.4 拦截器 Interceptor

##### 2.4.1 简介&快速入门

概述

+ 概念：是一种动态拦截方法调用的机制，类似于过滤器。Spring 框架中提供的，用来动态拦截控制器方法的执行
+ 作用：拦截请求，在指定的方法调用前后，根据业务需要执行预先设定的代码

<img src="./assets/image-20250820223348235.png" alt="image-20250820223348235" style="zoom:50%;" />

> 1. 定义拦截器，实现 HandlerInterceptor 接口，并重写其所有方法
> 2. 注册拦截器

+ LoginCheckInterceptor.java

```java
package com.itfeng.interceptor;

import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.stereotype.Component;
import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

@Component
public class LoginCheckInterceptor implements HandlerInterceptor {
    @Override // 目标资源方法运行前运行，返回true：放行，返回false：拦截
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println("preHandle...");
        return true;
    }

    @Override // 目标资源方法运行后运行
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        System.out.println("postHandle ...");
    }

    @Override // 视图渲染完毕后运行，最后运行
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        System.out.println("afterCompletion ...");
    }
}
```

+ WebConfig.java

```java
package com.itfeng.config;

import com.itfeng.interceptor.LoginCheckInterceptor;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration // 配置类
public class WebConfig implements WebMvcConfigurer {

    @Autowired
    private LoginCheckInterceptor loginCheckInterceptor;

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(loginCheckInterceptor).addPathPatterns("/**");
    }
}
```



------------------------------------------



##### 2.4.2 详解（拦截路径、执行流程）

###### 2.4.2.1 拦截路径

+ 拦截器可以根据需求，配置不同的拦截路径

```java
@Override
public void addInterceptors(InterceptorRegistry registry) {
    registry.addInterceptor(loginCheckInterceptor).addPathPatterns("/**").excludePathPatterns("/login");
}
```

| 拦截路径  | 含义                  | 举例                                                      |
| --------- | --------------------- | --------------------------------------------------------- |
| /*        | 一级路径              | 能匹配 /depts，/emps，/login，**不能匹配 /depts/1**       |
| /**       | 任意级路径            | 能匹配 /depts，/depts/1，/depts/1/2                       |
| /depts/*  | /depts 下的一级路径   | 能匹配 /depts/1，**不能匹配 /depts/1/2，/depts**          |
| /depts/** | /depts 下的任意级路径 | 能匹配 /depts，/depts/1，/depts/1/2，**不能匹配 /emps/1** |

###### 2.4.2.2 执行流程

tomcat 服务器并不识别我们所编写的 controller 程序，它是识别 servlet 程序的，springboot 中提供了 DispatcherServlet（前端控制器）

<img src="./assets/image-20250820233651203.png" alt="image-20250820233651203" style="zoom:50%;" />

Filter 与 Interceptor

+ 接口规范不同：过滤器需要实现 Filter 接口，而拦截器需要实现 HandlerInterceptor 接口
+ 拦截范围不同：过滤器 Filter 会拦截所有的资源，而 Interceptor 只会拦截 Spring 环境中的资源



-------------------------------



##### 2.4.3 登录校验 - Interceptor

+ LoginCheckInterceptor.java

```java
package com.itfeng.interceptor;

import com.alibaba.fastjson.JSONObject;
import com.itfeng.pojo.Result;
import com.itfeng.utils.JwtUtils;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.extern.slf4j.Slf4j;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;
import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

//@Slf4j
@Component
public class LoginCheckInterceptor implements HandlerInterceptor {

    private static Logger log = LoggerFactory.getLogger(LoginCheckInterceptor.class);


    @Override // 目标资源方法运行前运行，返回true：放行，返回false：拦截
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        // 1. 获取请求url
        String url = request.getRequestURI().toString();
        log.info("请求的url：{}", url);

        // 2. 判断请求url中是否包含login，如果包含，说明是登录操作，放行
        if (url.contains("login")) {
            log.info("登录操作，放行...");
            return true;
        }

        // 3. 获取请求头中的令牌（token）
        String jwt = request.getHeader("token");

        // 4. 判断令牌是否存在，如果不存在，返回错误结果（未登录）
        if (!StringUtils.hasLength(jwt)) {
            log.info("请求头token为空，返回未登录的信息");
            Result error = Result.error("NOT_LOGIN");
            // 手动转换，对象--json ----------> 阿里巴巴fastJSON工具包
            String notLogin = JSONObject.toJSONString(error);
            response.getWriter().write(notLogin); // 获取输出流
            return false;
        }

        // 5. 解析 token，如果解析失败，返回错误结果（未登录）
        try {
            JwtUtils.parseJWT(jwt);
        } catch (Exception e) { // jwt解析失败
            e.printStackTrace();
            log.info("解析令牌失败，返回登录错误信息");
            Result error = Result.error("NOT_LOGIN");
            // 手动转换，对象--json ----------> 阿里巴巴fastJSON工具包
            String notLogin = JSONObject.toJSONString(error);
            response.getWriter().write(notLogin); // 获取输出流
            return false;
        }

        // 6. 放行
        log.info("令牌合法，放行");
        return true;


    }

    @Override // 目标资源方法运行后运行
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        System.out.println("postHandle ...");
    }

    @Override // 视图渲染完毕后运行，最后运行
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        System.out.println("afterCompletion ...");
    }
}
```

+ WebConfig.java

```java
package com.itfeng.config;

import com.itfeng.interceptor.LoginCheckInterceptor;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration // 配置类
public class WebConfig implements WebMvcConfigurer {

    @Autowired
    private LoginCheckInterceptor loginCheckInterceptor;

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(loginCheckInterceptor).addPathPatterns("/**").excludePathPatterns("/login");
    }
}
```



------------------------------



### 3. 异常处理

+ 程序开发过程中不可避免的会遇到异常现象

方法：

+ 全局异常处理器

```java
package com.itfeng.exception;

import com.itfeng.pojo.Result;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

/**
 * 全局异常处理器
 */
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(Exception.class) // 捕获所有异常
    public Result ex(Exception ex) {
        ex.printStackTrace();
        return Result.error("对不起，操纵失败，请联系管理员");
    }
}
```

@RestControllerAdvice = @ControllerAdvice + @ResponseBody



----------------------------



## 五、事务管理



### 1. 事务回顾

概念

+ **事务** 是一组操作的集合，它是一个不可分割的工作单位，这些操作**要么同时成功，要么同时失败**

操作

+ 开启事务（一组操作开始前，开启事务）：`start transaction / begin`
+ 提交事务（这组操作全部成功后，提交事务）：`commit`
+ 回滚事务（中间任何一个操作出现异常，回滚事务）：`rollback`



------------------



### 2. Spring 事务管理

#### 2.1 案例

+ 完善删除部门功能：删除部门，同时删除该部门下的员工

<img src="./assets/image-20250821223219630.png" alt="image-20250821223219630" style="zoom:50%;" />

#### 2.2 @Transactional

+ 注解：`@Transactional`
+ 未知：业务（service）层的方法上、类上、接口上
+ 作用：将当前方法交给 spring 进行事务管理，方法执行前，开启事务；成功执行完毕，提交事务；出现异常，回滚事务

Spring事务管理日志开关

```yaml
# 开启事务管理日志
logging:
  level:
    org.springframework.jdbc.support.jdbcTransactionManager: debug
```

+ DeptServiceImpl.java

```java
@Transactional // spring事务管理
@Override
public void delete(Integer id) {
    deptMapper.deleteById(id); // 根据ID删除部门

    empMapper.deleteByDeptId(id); // 根据部门ID删除该部门下的员工
}
```



--------------------------



### 3. 事务进阶

#### 3.1 rollbackFor

+ 默认情况下，只有出现 RuntimeException 才回滚异常。rollbackFor 属性用于控制出现何种异常类型，回滚事务

```java
@Transactional(rollbackFor = Exception.class) // 出现所有的异常都会出现事务的回滚
```



---------------------



#### 3.2 propagation

+ 事务传播行为：指的就是当一个事务方法被另一个事务方法调用时，这个事务方法应该如何进行事务控制

例如 A 方法和 B 方法都由事务管理，但是在 A 方法中调用了 B 方法，折旧涉及了事务的传播行为

##### 3.2.1 传播行为

| 属性值        | 含义                                                         |
| ------------- | ------------------------------------------------------------ |
| REQUIRED      | 【默认值】需要事务，有则加入，无则创建新事务                 |
| REQUIRES_NEW  | 需要新事务，无论有无，总是创建新事务                         |
| SUPPORTS      | 支持事务，有则加入，无则在无事务状态中运行                   |
| NOT_SUPPORTED | 不支持事务，在无事务状态下运行，如果当前存在已有事务，则挂起当前事务 |
| MANDATORY     | 必须有事务，否则抛异常                                       |
| NEVER         | 必须没事务，否则抛异常                                       |
| ...           |                                                              |



##### 3.2.2 案例

> 需求：解散部门时，无论是成功还是失败，都要记录操作日志
>
> 步骤：
>
> 1. 解散部门：删除部门、删除部门下的员工
> 2. 记录日志到数据库表中

+ sql

```sql
create table dept_log
(
    id          int unsigned primary key auto_increment comment '主键ID',
    create_time datetime     not null comment '操作时间',
    description varchar(300) not null comment '操作描述'
) comment '部门操作日志表'
```

+ DeptServiceImpl

```java
@Transactional
@Override
public void delete(Integer id) {
    try {
        deptMapper.deleteById(id); // 根据ID删除部门

        empMapper.deleteByDeptId(id); // 根据部门ID删除该部门下的员工
    } finally {
        DeptLog deptLog = new DeptLog();
        deptLog.setCreateTime(LocalDateTime.now());
        deptLog.setDescription("执行了解散部门的操作");
        deptLogService.insert(deptLog);
    }
}
```

+ DeptLogServiceImpl.java

```java
package com.itfeng.service.impl;

import com.itfeng.mapper.DeptLogMapper;
import com.itfeng.pojo.DeptLog;
import com.itfeng.service.DeptLogService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

@Service
public class DeptLogServiceImpl implements DeptLogService {

    @Autowired
    private DeptLogMapper deptLogMapper;

    @Transactional(propagation = Propagation.REQUIRES_NEW) // 需要一个新的事务
    @Override
    public void insert(DeptLog deptLog) {
        deptLogMapper.insert(deptLog);
    }
}
```

+ DeptLogMapper.java

```java
package com.itfeng.mapper;

import com.itfeng.pojo.DeptLog;
import org.apache.ibatis.annotations.Insert;
import org.apache.ibatis.annotations.Mapper;

@Mapper
public interface DeptLogMapper {

    @Insert("insert into dept_log (create_time, description) values (#{createTime}, #{description})")
    void insert(DeptLog deptLog);
}
```

##### 3.2.3 场景

+ REQUIRED：大部分情况下都是用该传播行为
+ REQUIRES_NEW：但我们不希望事务之间相互影响时，可以使用该传播行为。比如：下订单前需要记录日志，不论订单保存成功与否，都需要保证日志记录能够记录成功



------------------



## 六、AOP

### 1. AOP 基础

#### 1.1 AOP 概念

+ AOP：Aspect Oriented Programming（**面向切面编程、面向方面编程**），其实就是面向特定方法编程
+ 场景
  + 案例部分功能运行较慢，定位执行耗时较长的业务方法，此时需要统计每一个业务方法的执行耗时
+ 实现
  + 动态代理就是面向切面编程最主流的实现。而 SpringAOP 是 Spring 框架的高级技术。旨在管理 bean 对象的过程中，主要通过底层的动态代理机制，对特定的方法进行编程

面向切面编程：面向特定的一个或者多个方法进行编程



-------------------------------



#### 1.2 AOP 快速入门

> 统计各个业务层方法执行耗时
>
> + 导入依赖：在 pom.xml 中导入 AOP 的依赖
> + 编写 AOP 程序：针对特定方法根据业务需要进行编程

+ 依赖

```xml
<!-- AOP-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-aop</artifactId>
</dependency>
```

+ 编写 AOP 程序：针对于特定方法根据业务需要进行编程

```java
package com.itfeng.aop;

import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

//@Slf4j
@Component
@Aspect // 声明当前类为AOP类
public class TimeAspect {

    private static Logger log = LoggerFactory.getLogger(TimeAspect.class);

    // 切入点表达式
    @Around("execution(* com.itfeng.service.*.*(..))") // 表示在运行这个包下所有的接口或者是类当中的方法时都会运行这个方法中所封装的公共的逻辑代码
    public Object recordTime(ProceedingJoinPoint joinPoint) throws Throwable {
        // 1. 记录开始时间
        long begin = System.currentTimeMillis(); // 拿到当前时间的毫秒值

        // 2. 调用原始方法运行
        Object result = joinPoint.proceed();// 表示要运行原始方法，result表示原始方法的返回值


        // 3. 记录结束时间，计算方法执行耗时
        long end = System.currentTimeMillis(); // 拿到结束时间
        log.info(joinPoint.getSignature() + "方法执行耗时：{}ms", end - begin); // joinPoint.getSignature() 拿到原始方法的签名

        return result;
    }
}
```

##### 1.2.1 场景

+ 记录操作日志
+ 权限控制
+ 事务管理
+ 。。。

##### 1.2.2 优势

+ 代码无侵入
+ 减少重复代码
+ 提高开发效率
+ 维护方便



--------------------------



#### 1.3 AOP 核心概念

+ 连接点：JoinPoint，可以被 AOP 控制的方法（暗含方法执行时的相关信息）【其实所有的方法都是连接点】
+ 通知：Advice，指哪些重复的逻辑，也就是共性功能（最终体现为一个方法）【封装共性功能的方法】
+ 切入点：PointCut，匹配连接点的条件，通知仅会在切入点方法执行时被应用【实际被 AOP 控制的方法 / 需要被增强的方法】

+ 切面：Aspect，描述通知与切入点的对应关系（通知 + 切入点）
+ 目标对象：Target，通知所应用的对象

<img src="./assets/image-20250823174243904.png" alt="image-20250823174243904" style="zoom:50%;" />

<img src="./assets/image-20250823174228967.png" alt="image-20250823174228967" style="zoom:50%;" />

SpringAOP 它的底层是通过动态代理技术实现的，在程序运行的时候会自动的基于动态代理技术为目标对象自动生成一个对应的代理对象，在代理对象当中就会对目标对象当中的原始方法进行功能的增强，增强的逻辑就是我们定义的通知

<img src="./assets/image-20250823174605044.png" alt="image-20250823174605044" style="zoom:50%;" />

程序注入的时候注入的就是代理对象，调用的也是代理对象中的 list 方法，而这个 list 方法已经进行了功能的增强

##### 小结

1. AOP 核心概念

+ 连接点（JoinPoint）
+ 切入点（PointCut）
+ 通知（Advice）
+ 切面（Aspect）
+ 目标对象（Target）

2. AOP 执行流程

+ 一旦进行了 AOP 程序开发，那么最终运行的就不再是原始的目标对象，而是基于目标对象所生成的代理对象



---------------------------------



### 2. AOP 进阶

### 2.1 通知类型

1. `@Around`：环绕通知，此注解标注的通知方法在目标方法前、后都被执行
2. `@Before`：前置通知，此注解标注的通知方法在目标方法前被执行
3. `@After`：后置通知，此注解标注的通知方法在目标方法后被执行，无论是否有异常都会执行
4. `@AfterReturning`：返回后通知，此注解标注的通知方法在目标方法被执行，有异常不会执行
5. `@AfterThrowing`：异常后通知，此注解标注的通知方法发生异常后执行

#### 2.1.1 注意事项

+ `@Around` 环绕通知需要自己调用 ProceedingJoinPoint.proceed() 来让原始方法执行，其他通知不需要考虑目标方法执行
+ `@Around` 环绕通知方法的返回值，必须指定为 Object，来接收原始方法的返回值（如果是 void 就拿不到返回值，因为你并没有把原始方法执行的返回值返回回去）

#### 2.1.2 @PointCut

+ 该注解的作用是将公共的切点表达式抽取出来，需要用到时引用该切点表达式即可

```java
@Pointcut("execution(* com.itfeng.service.impl.DeptServiceImpl.*(..))")
private void pt(){}

@Before("pt()")
public void before() {
    log.info("before ...");
}
```

#### 代码演示

```java
package com.itfeng.aop;

import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

//@Slf4j
@Component
@Aspect
public class MyAspect1 {

    private static Logger log = LoggerFactory.getLogger(MyAspect1.class);

    @Pointcut("execution(* com.itfeng.service.impl.DeptServiceImpl.*(..))")
    private void pt(){}

    @Before("pt()")
    public void before() {
        log.info("before ...");
    }

    @Around("pt()")
    public Object around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {
        log.info("around before ...");

        // 调用目标对象的原始方法执行
        Object result = proceedingJoinPoint.proceed();

        log.info("around after ...");
        return result;
    }

    @After("pt()")
    public void after() {
        log.info("after ...");
    }

    @AfterReturning("pt()")
    public void afterReturning() {
        log.info("afterReturning ...");
    }

    @AfterThrowing("pt()")
    public void afterThrowing() {
        log.info("afterThrowing ...");
    }
}
```

#### 小结

1. 通知类型

+ @Before（前置通知）
+ @After（后置通知）
+ @Around（环绕通知，**重点**）
+ @AfterReturning（返回后通知）
+ @AfterThrowing（异常后通知）



-------------------------------



### 2.2 通知顺序

当有多个切面的切入点都匹配到了目标方法，目标方法运行时，多个通知方法都会被执行

执行顺序：

1. 不同切面类中，默认按照切面类的**类名字母排序**

+ 目标方法前的通知方法：字母排名靠前的先执行
+ 目标方法后的通知方法：字母排名靠前的后执行

2. 用 `@Order(数字)` 加在切面类上来控制顺序

+ 目标方法前的通知方法：数字小的先执行
+ 目标方法后的通知方法：数字小的后执行

#### 代码演示

```java
package com.itfeng.aop;

import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.annotation.After;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;

@Order(1)
//@Slf4j
@Component
@Aspect
public class MyAspect4 {

    private static Logger log = LoggerFactory.getLogger(MyAspect4.class);

    @Before("execution(* com.itfeng.service.impl.DeptServiceImpl.*(..))")
    public void before() {
        log.info("before ...4");
    }

    @After("execution(* com.itfeng.service.impl.DeptServiceImpl.*(..))")
    public void after() {
        log.info("after ...4");
    }
}
```



-----------------------------------



### 2.3 切入点表达式

+ 切入点表达式：描述切入点方法的一种表达式
+ 作用：主要用来决定项目中的哪些方法需要加入通知
+ 常见形式：

1. `execution(...)`：根据方法的签名来匹配
2. `@annotation(...)`：根据注解匹配

#### 2.3.1 切入点表达式 - execution

execution 主要根据方法的返回值、报名、类名、方法名、方法参数等信息来匹配，语法为：

```java
execution(访问修饰符? 返回值 包名.类名.?方法名(方法参数) throw 异常?)
```

+ 其中带 **?** 的表示可以省略的部分
  + 访问修饰符：可省略（比如：public、protected）
  + 包名.类名：可省略
  + throws 异常：可省略（注意是方法上声明抛出的异常，不是实际抛出的异常）

+ 可以使用通配符描述切入点

  + ***** ：单个独立的任意符号，可以通配任意返回值、包名、类名、方法名、任意类型的一个参数，也可以通配包、类、方法名的一部分

  ```java
  execution(* com.*.service.*.update*(*))
  ```

  + **..** ：多个连续的任意符号，可以通配任意层级的包，或任意类型、任意个数的参数

  ```java
  execution(* com.itfeng..DeptService.*(..))
  ```

注意事项：

+ 根据业务需要，可以使用 且（&&）、或（||）、非（!）来组合比较复杂的切入带你表达式

书写建议：

+ 所有业务**方法名**在**命名**时尽量**规范**，方便切入点表达式快速匹配。如：查询类方法都是 find 开头，更新类方法都是 update 开头
+ 描述切入点方法通常**基于接口描述**，而不是直接描述实现类，**增强拓展性**
+ 在满足业务需求的前提下，**尽量缩小切入点的匹配范围**。如：包名匹配尽量不适用 ..，使用 * 匹配单个包

##### 代码演示

```java
package com.itfeng.aop;

import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

// 切面类
//@Slf4j
@Aspect
@Component
public class MyAspect6 {

    private static Logger log = LoggerFactory.getLogger(MyAspect6.class);

//    @Pointcut("execution(public void com.itfeng.service.impl.DeptServiceImpl.delete(java.lang.Integer))")
//    @Pointcut("execution(void com.itfeng.service.impl.DeptServiceImpl.delete(java.lang.Integer))")
//    @Pointcut("execution(void delete(java.lang.Integer))") // 包名.类名不建议省略
//    @Pointcut("execution(void com.itfeng.service.DeptService.delete(java.lang.Integer))")
//    @Pointcut("execution(void com.itfeng.service.DeptService.*(java.lang.Integer))")

//    @Pointcut("execution(* com.*.service.DeptService.*(*))")
//    @Pointcut("execution(* com.*.service.DeptService.*(*))")
//    @Pointcut("execution(* com.itfeng.service.*Service.delete*(*))")

//    @Pointcut("execution(* com.itfeng.service.DeptService.*(..))")
//    @Pointcut("execution(* com..DeptService.*(..))")
//    @Pointcut("execution(* com..*.*(..))")
//    @Pointcut("execution(* *(..))") // 慎用

    @Pointcut("execution(* com.itfeng.service.DeptService.list()) || " +
            "execution(* com.itfeng.service.DeptService.delete(java.lang.Integer))")
    private void pt() {
    }

    @Before("pt()")
    public void before() {
        log.info("MyAspect6 ... before ...");
    }
}
```



#### 2.3.2 切入点表达式 - @annotation

+ @annotation 切入点表达式，用于匹配标识有特定注解的方法

```java
@annotation(com.itfeng.anno.log)
```

##### 代码演示

+ aop/MyLog.java

```java
package com.itfeng.aop;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Retention(RetentionPolicy.RUNTIME) // 注解运行时有效
@Target(ElementType.METHOD) // 作用在方法上
public @interface MyLog {
}
```

+ MyAspect7.java

```java
package com.itfeng.aop;

import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

// 切面类
//@Slf4j
@Aspect
@Component
public class MyAspect7 {

    private static Logger log = LoggerFactory.getLogger(MyAspect7.class);

    @Pointcut("@annotation(com.itfeng.aop.MyLog)") // 要匹配方法上加了有 MyLog 这个注解的方法
    private void pt() {
    }

    @Before("pt()")
    public void before() {
        log.info("MyAspect7 ... before ...");
    }
}
```



--------------------------------



### 2.4 连接点

+ 在 Spring 中用 **JoinPoint** 抽象了连接点，用它可以获得方法执行时的相关信息，如目标类名、方法名、方法参数等
  + 对于 AAround 通知，获取连接点信息只能使用 ProceedingJoinPoint
  + 对于其他四种类型，获取连接点信息只能使用 JoinPoint，它是 ProceedingJoinPoint 的父类型

#### 代码演示

```java
package com.itfeng.aop;

import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import java.util.Arrays;

// 切面类
//@Slf4j
@Aspect
@Component
public class MyAspect8 {

    private static Logger log = LoggerFactory.getLogger(MyAspect8.class);

    @Pointcut("@annotation(com.itfeng.aop.MyLog)") // 要匹配方法上加了有 MyLog 这个注解的方法
    private void pt() {
    }

    @Before("pt()")
    public void before(JoinPoint joinPoint) {
        log.info("MyAspect8 ... before ...");
    }

    @Around("pt()")
    public Object around(ProceedingJoinPoint joinPoint) throws Throwable {
        log.info("MyAspect8 around before ...");

        // 1. 获取目标对象的类名
        String className = joinPoint.getTarget().getClass().getName();
        log.info("目标对象的类名：{}", className);

        // 2. 获取目标方法的方法名
        String methodName = joinPoint.getSignature().getName();
        log.info("目标方法的方法名：{}", methodName);

        // 3. 获取目标方法运行时传入的参数
        Object[] args = joinPoint.getArgs();
        log.info("目标方法运行时传入的参数：{}", Arrays.toString(args));

        // 4. 放行目标方法的执行
        Object result = joinPoint.proceed();

        // 5. 获取目标方法运行时的返回值
        log.info("目标方法运行时的返回值：{}", result);

        log.info("MyAspect8 around after ...");
        return result;
    }
}
```



---------------------------------



### 3. AOP 案例

> 操作日志
>
> + 日志信息包含：操作人、操作时间、执行方法的全类名、执行方法名、方法运行时参数、返回值、方法执行时长

思路分析：

+ 需要对所有业务类中的增、删、改方法添加统一功能，使用 **AOP** 技术最为方便
+ 由于增、删、改方法名没有规律，可以自定义 `@Log` 注解完成目标方法匹配

步骤： 

+ 准备
  + 在案例工程中引入 AOP 起步依赖
  + 导入资料中准备好的数据库表结构，并引入对应的实体类
+ 编码
  + 自定义注解 @Log
  + 定义切面类，完成记录操作日志的逻辑

获取当前登录用户

+ 获取 request 对象，从请求头中获取到 jwt 令牌，解析令牌获取出当前用户的 id

```java
@Autowired
private HttpServletRequest request;
```

```java
// 获取请求头中的jwt令牌，解析令牌
String jwt = request.getHeader("token");
Claims claims = JwtUtils.parseJWT(jwt);
Integer operateUser = (Integer) claims.get("id");
```

#### 代码实现

+ anno/Log.java

```java
package com.itfeng.anno;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Log {
}
```

+ LogAspect.java

```java
package com.itfeng.aop;

import com.alibaba.fastjson.JSONObject;
import com.itfeng.mapper.OperateLogMapper;
import com.itfeng.pojo.OperateLog;
import com.itfeng.utils.JwtUtils;
import io.jsonwebtoken.Claims;
import jakarta.servlet.http.HttpServletRequest;
import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.time.LocalDateTime;
import java.util.Arrays;

//@Slf4j
@Component
@Aspect // 切面类
public class LogAspect {

    private static Logger log = LoggerFactory.getLogger(LogAspect.class);

    @Autowired
    private HttpServletRequest request;
    @Autowired
    private OperateLogMapper operateLogMapper;

    @Around("@annotation(com.itfeng.anno.Log)")
    public Object recordLog(ProceedingJoinPoint joinPoint) throws Throwable {

        // 操作人ID - 当前登录员工ID
        // 获取请求头中的jwt令牌，解析令牌
        String jwt = request.getHeader("token");
        Claims claims = JwtUtils.parseJWT(jwt);
        Integer operateUser = (Integer) claims.get("id");

        // 操作时间
        LocalDateTime operateTime = LocalDateTime.now();

        // 操作类名
        String className = joinPoint.getTarget().getClass().getName();

        // 操作方法名
        String methodName = joinPoint.getSignature().getName();

        // 操作方法参数
        Object[] args = joinPoint.getArgs();
        String methodParams = Arrays.toString(args);

        long begin = System.currentTimeMillis();
        // 调用与原始目标方法运行
        Object result = joinPoint.proceed();
        long end = System.currentTimeMillis();

        // 方法返回值
        String returnValue = JSONObject.toJSONString(result);

        // 操作耗时
        Long costTime = end - begin;

        // 记录操作日志
        OperateLog operateLog = new OperateLog(null, operateUser, operateTime, className,
                methodName, methodParams, returnValue, costTime);
        operateLogMapper.insert(operateLog);

        log.info("AOP记录操作日志：{}", operateLog);

        return result;
    }
}
```



---------------------------



